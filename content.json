{"pages":[{"title":"404","text":"","path":"404/index.html","date":"05-31","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"05-31","excerpt":""},{"title":"about","text":"第一次弄个人网站开心 哈哈哈","path":"about/index.html","date":"05-31","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"05-31","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"05-31","excerpt":""}],"posts":[{"title":"Java中的异常处理","text":"异常处理Java中的异常体系的基类是Throwable，它主要又两个子类：Error和Exception。 Error是指程序无法处理的错误，这类错误大多与开发人员无关。 Exception主要分为两块：运行时异常和非运行时异常。运行时异常为RuntimeException以及其子类。除此之位的Exception类子类均为非运行时异常。 运行时异常：NullpointException、indexoutofboundsException、ClassCastException等。运行时异常多指程序逻辑上出现问题（也就是自己写的代码逻辑出了问题），这类异常都可以通过逻辑出来来避免（比如判断语句判断是否越界、是否属于某类型、是否为null），所以编译器将这些错误交给程序员来把控，在编译期即使手动抛出了一个运行时异常不去捕获，编译器也会通过。因为这类异常叫做“未检查异常（uncheck）”。同样属于未检查异常的还有Error。 非运行时异常：IOException、lClassNotFoundException等。又称作检查异常（check）。对于检查异常，在可能发生异常的位置需要用try-catch块去捕获异常并处理，如果不处理，它就会向上上层一直调用抛出，直到被处理为止。 throw 与 throws throws*关键字要在方法签名中使用，用于声明该方法可能抛出异常。throws可以理解成时一种通知行为，没有实际的抛出异常的动作，而仅仅是告诉调用他的上层函数，这里可能会抛出这个异常； throw*用于在函数体内语句中，表示抛出一个实际的异常的实际动作，如果在函数内没有捕获并处理，那么将会一直向上抛出这个异常直到被main（）/Thread.run()抛出。当一个函数throws声明函数可能抛出一个非运行时异常（检查异常）时，那么即使这个函数内部不显示使用throw，调用它的上层函数也必须包含处理这个异常的代码 。 1.区别 Error(错误 内存错误等 处理方式： 修改程序) Exception（异常） 进行处理2.关键字 try catch finallytry(有可能会产生异常的代码）catch(处理方式 “可以不处理”) finally(不管try里面会不会产生异常 和 catch 是否处理掉该异常 finally均会继续执行)catch的参数为可能产生异常的对象当在catch中抛出 throws Runtime exceotion时 程序终止运行3.throw（在catch里面） 抛出一个异常对象 并可以带参数 抛出异常信息 4.throw (在方法名后面) 代表抛出一个异常对象,然后由调用者进行处理","path":"2019/07/22/Java中的异常处理/","date":"07-22","excerpt":"","tags":[{"name":"Exception","slug":"Exception","permalink":"https://starsuomali.github.io/tags/Exception/"}]},{"title":"MD个人简历","text":"我的个人简历 MarkDown版本 联系方式 手机：15004708276 Email：suomalx@foxmail.com 微信：l863967598lx 个人信息 李星/男/1994.11.5 本科/呼伦贝尔学院计算机系软件工程专业/英语四级 个人博客：https://www.starsuomali.club/ Github：https://github.com/Starsuomali 期望职位：Javaweb后端程序员 期望城市：北京 技术栈以下均为有实际使用经验的技能 web开发：Java/Ajax/Servlet/Jsp/Html/Css Web框架：Spring/SpringMVC/SpringBoot/MyBatis 前端框架：Bootstrap 开发工具：Eclipse/idea/Vscode/Git/Tomcat 数据库相关：MySQL 单元测试：JUnit 工作经历2018.7 ~ 2019.1 / 浪潮云服务集团 / Java开发实习 系统bug修复、上报 数据库维护工作（MySql） 部分功能的本地（个性）化开发 编写个性化功能的使用方法 项目经历2018.3 ~2018.6 / 学生学科竞赛管理系统项目项目描述项目针对大学中一些实践性较强的并且和互联网有交集的课程，提供一个学生和教师可以快捷互动的平台。具体实现了教师在相应院系的学科下提出一个作品要求，学生收到通知后在规定时间内在该条要求下提交作品，并由教师统一评分后在平台上公布成绩。 责任描述该项目为个人作品，项目使用了SSM框架来实现后台的整合，视图层为Jsp页面，数据库使用Mysql数据库。在页面样式上直接采用了Bootstrap的成熟样式。与页面交互时为了实现不刷新页面的提示功能使用了Ajax动态交互技术。在实现时遇到了mysql数据库汉字乱码的问题，通过查找相关技术博客得到解决。调整前端页面时接触了大量的Javascript代码，了解了回调函数。 2017.11 ~2017.12 / 酒店管理系统项目项目描述使用基础的JavaEE所做的一套酒店住房管理系统。该系统为B/S架构。用户分为管理员和员工俩种角色。管理员可以指定房间的金额，查看住房记录和收益情况以及管理员工信息。员工完成了预定、退订房间，更换房间，金额结算等。 责任描述项目为3人小组合作完成，使用到了Servlet、Jsp、Html5、Css、JavaBean、Struts2等JavaEE技术。本人负责员工管理和金额结算功能的编写。在编写功能结算功能时，遇到日期类型对象的计算，经过查询相关的技术博客，最终通过入住日期和退房日期来计算天数，解决了金额计算的问题。 自我评价对编程充满热爱，自学能力较强，喜欢和同行交流技术知识。曾参加了第十二届内蒙古自治区acm程序设计大赛。对自己要求严格，能够认真及时负责地完成交付的任务。 感谢您花时间阅读我的简历，期待能有机会和您共事。","path":"2019/07/02/MD个人简历/","date":"07-02","excerpt":"我的个人简历 MarkDown版本","tags":[{"name":"个人简历","slug":"个人简历","permalink":"https://starsuomali.github.io/tags/个人简历/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://starsuomali.github.io/tags/MarkDown/"}]},{"title":"sql面试题目(转)","text":"SQL常见面试题 转自: Different桐 SQL常见面试题 (转) Different桐1.用一条SQL 语句 查询出每门课都大于80 分的学生姓名name kecheng fenshu张三 语文 81张三 数学 75李四 语文 76李四 数学 90王五 语文 81王五 数学 100王五 英语 90 A: select distinct name from table where name not in (select distinct name from table where fenshu&lt;=80)select name from table group by name having min(fenshu)&gt;80 2. 学生表 如下:自动编号 学号 姓名 课程编号 课程名称 分数1 2005001 张三 0001 数学 692 2005002 李四 0001 数学 893 2005001 张三 0001 数学 69删除除了自动编号不同, 其他都相同的学生冗余信息 A: delete tablename where 自动编号 not in(select min( 自动编号) from tablename group by学号, 姓名, 课程编号, 课程名称, 分数) 3.一个叫 team 的表，里面只有一个字段name, 一共有4 条纪录，分别是a,b,c,d, 对应四个球对，现在四个球对进行比赛，用一条sql 语句显示所有可能的比赛组合.你先按你自己的想法做一下，看结果有我的这个简单吗？ 答：select a.name, b.namefrom team a, team bwhere a.name &lt; b.name 4.请用SQL 语句实现：从TestDB 数据表中查询出所有月份的发生额都比101 科目相应月份的发生额高的科目。请注意：TestDB 中有很多科目，都有1 －12 月份的发生额。AccID ：科目代码，Occmonth ：发生额月份，DebitOccur ：发生额。数据库名：JcyAudit ，数据集：Select * from TestDB 答：select a.* from TestDB a,(select Occmonth,max(DebitOccur) Debit101ccur from TestDB where AccID=’101’ group by Occmonth) bwhere a.Occmonth=b.Occmonth and a.DebitOccur&gt;b.Debit101ccur 5.面试题：怎么把这样一个表儿year month amount1991 1 1.11991 2 1.21991 3 1.31991 4 1.41992 1 2.11992 2 2.21992 3 2.31992 4 2.4查成这样一个结果year m1 m2 m3 m41991 1.1 1.2 1.3 1.41992 2.1 2.2 2.3 2.4 答案一、select year,(select amount from aaa m where month=1 and m.year=aaa.year) as m1,(select amount from aaa m where month=2 and m.year=aaa.year) as m2,(select amount from aaa m where month=3 and m.year=aaa.year) as m3,(select amount from aaa m where month=4 and m.year=aaa.year) as m4from aaa group by year 6. 说明：复制表( 只复制结构, 源表名：a新表名：b)SQL: select * into b from a where 1&lt;&gt;1 (where1=1，拷贝表结构和数据内容)Oracle:create table b As Select * from a where 1=2 [&lt;&gt;（不等于）(SQL Server Compact) 比较两个表达式。 当使用此运算符比较非空表达式时，如果左操作数不等于右操作数，则结果为 TRUE。 否则，结果为 FALSE。] 7. 说明：拷贝表( 拷贝数据, 源表名：a目标表名：b)SQL: insert into b(a, b, c) select d,e,f from a; 8. 说明：显示文章、提交人和最后回复时间SQL: select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b 9. 说明：外连接查询( 表名1 ：a表名2 ：b)SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUTER JOIN b ON a.a = b.c ORACLE：select a.a, a.b, a.c, b.c, b.d, b.f from a ,b where a.a = b.c(+) 10. 说明：日程安排提前五分钟提醒SQL: select * from 日程安排 where datediff(‘minute’,f 开始时间,getdate())&gt;5 11. 说明：两张关联表，删除主表中已经在副表中没有的信息SQL:Delete from info where not exists (select * from infobz where info.infid=infobz.infid ) 12.有两个表A 和B ，均有key 和value 两个字段，如果B 的key 在A 中也有，就把B 的value 换为A 中对应的value这道题的SQL 语句怎么写？ update b set b.value=(select a.value from a where a.key=b.key) where b.id in(select b.id from b,a where b.key=a.key); 13.高级sql 面试题原表: courseid coursename score1 Java 702 oracle 903 xml 404 jsp 30 5 servlet 80为了便于阅读, 查询此表后的结果显式如下( 及格分数为60): courseid coursename score mark1 Java 70 pass2 oracle 90 pass3 xml 40 fail4 jsp 30 fail 5 servlet 80 pass写出此查询语句 select courseid, coursename ,score ,decode（sign(score-60),-1,’fail’,’pass’) as mark from course 完全正确 SQL&gt; desc course_vName Null? Type COURSEID NUMBERCOURSENAME VARCHAR2(10)SCORE NUMBER SQL&gt; select * from course_v; COURSEID COURSENAME SCORE 1 java 702 oracle 903 xml 404 jsp 305 servlet 80 SQL&gt; select courseid, coursename ,score ,decode(sign(score-60),-1,’fail’,’pass’) as mark from course_v; COURSEID COURSENAME SCORE MARK 1 java 70 pass2 oracle 90 pass3 xml 40 fail4 jsp 30 fail5 servlet 80 pass SQL面试题（1）create table testtable1( id int IDENTITY,department varchar(12)) select * from testtable1insert into testtable1 values(‘设计’)insert into testtable1 values(‘市场’)insert into testtable1 values(‘售后’)/* 结果id department1 设计2 市场3 售后/ create table testtable2( id int IDENTITY,dptID int,name varchar(12)) insert into testtable2 values(1,’张三’)insert into testtable2 values(1,’李四’)insert into testtable2 values(2,’王五’)insert into testtable2 values(3,’彭六’)insert into testtable2 values(4,’陈七’)/用一条SQL语句，怎么显示如下结果id dptID department name1 1 设计 张三2 1 设计 李四3 2 市场 王五4 3 售后 彭六5 4 黑人 陈七*/ 答案： SELECT testtable2.* , ISNULL(department,’黑人’)FROM testtable1 right join testtable2 on testtable2.dptID = testtable1.ID 也做出来了可比这方法稍复杂。 sql面试题（2）有表A，结构如下：A: p_ID p_Num s_id1 10 011 12 022 8 013 11 013 8 03其中：p_ID为产品ID，p_Num为产品库存量，s_id为仓库ID。请用SQL语句实现将上表中的数据合并，合并后的数据为：p_ID s1_id s2_id s3_id1 10 12 02 8 0 03 11 0 8其中：s1_id为仓库1的库存量，s2_id为仓库2的库存量，s3_id为仓库3的库存量。如果该产品在某仓库中无库存量，那么就是0代替。 结果： select p_id ,sum(case when s_id=1 then p_num else 0 end) as s1_id,sum(case when s_id=2 then p_num else 0 end) as s2_id,sum(case when s_id=3 then p_num else 0 end) as s3_idfrom myPro group by p_id SQL面试题（3） 触发器的作用？ 答：触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。 什么是存储过程？用什么来调用？ 答：存储过程是一个预编译的SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL ，使用存储过程比单纯SQL 语句执行要快。可以用一个命令对象来调用存储过程。 索引的作用？和它的优点缺点是什么？ 答：索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。 什么是内存泄漏？ 答：一般我们所说的内存泄漏指的是堆内存的泄漏。堆内存是程序从堆中为其分配的，大小任意的，使用完后要显示释放内存。当应用程序用关键字new 等创建对象时，就从堆中为它分配一块内存，使用完后程序调用free 或者delete 释放该内存，否则就说该内存就不能被使用，我们就说该内存被泄漏了。 维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？ 答：我是这样做的，尽可能使用约束，如check, 主键，外键，非空字段等来约束，这样做效率最高，也最方便。其次是使用触发器，这种方法可以保证，无论什么业务系统访问数据库都可以保证数据的完整新和一致性。最后考虑的是自写业务逻辑，但这样做麻烦，编程复杂，效率低下。 什么是事务？什么是锁？ 答：事务就是被绑定在一起作为一个逻辑工作单元的SQL 语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID 测试，即原子性，一致性，隔离性和持久性。 锁：在所以的 DBMS中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。当然锁还分级别的。 什么叫视图？游标是什么？ 答：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。 游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 为管理业务培训信息，建立3个表： S(S#,SN,SD,SA)S#,SN,SD,SA分别代表学号，学员姓名，所属单位，学员年龄 C(C#,CN)C#,CN分别代表课程编号，课程名称 SC(S#,C#,G) S#,C#,G分别代表学号，所选的课程编号，学习成绩 使用标准SQL嵌套语句查询选修课程名称为’税收基础’的学员学号和姓名? 答案：select s# ,sn from s where S# in(select S# from c,sc where c.c#=sc.c# and cn=’税收基础’) 使用标准SQL嵌套语句查询选修课程编号为’C2’的学员姓名和所属单位? 答：select sn,sd from s,sc where s.s#=sc.s# and sc.c#=’c2’ 使用标准SQL嵌套语句查询不选修课程编号为’C5’的学员姓名和所属单位? 答：select sn,sd from s where s# not in(select s# from sc where c#=’c5’) 查询选修了课程的学员人数 答：select 学员人数=count(distinct s#) from sc 查询选修课程超过5门的学员学号和所属单位? 答：select sn,sd from s where s# in(select s# from sc group by s# having count(distinct c#)&gt;5) SQL面试题（4）1.查询A(ID,Name)表中第31至40条记录，ID作为主键可能是不是连续增长的列，完整的查询语句如下： select top 10 * from A where ID &gt;(select max(ID) from (select top 30 ID from A order by A ) T) order by A 2.查询表A中存在ID重复三次以上的记录,完整的查询语句如下：select * from(select count(ID) as count from table group by ID)T where T.count&gt;3 SQL面试题（5） 在面试应聘的SQL Server数据库开发人员时，我运用了一套标准的基准技术问题。下面这些问题是我觉得能够真正有助于淘汰不合格应聘者的问题。它们按照从易到难的顺序排列。当你问到关于主键和外键的问题时，后面的问题都十分有难度，因为答案可能会更难解释和说明，尤其是在面试的情形下。 你能向我简要叙述一下SQL Server 2000中使用的一些数据库对象吗? 你希望听到的答案包括这样一些对象:表格、视图、用户定义的函数，以及存储过程;如果他们还能够提到像触发器这样的对象就更好了。如果应聘者不能回答这个基本的问题，那么这不是一个好兆头。 NULL是什么意思? NULL(空)这个值是数据库世界里一个非常难缠的东西，所以有不少应聘者会在这个问题上跌跟头您也不要觉得意外。 NULL这个值表示UNKNOWN(未知):它不表示“”(空字符串)。假设您的SQL Server数据库里有ANSI_NULLS，当然在默认情况下会有，对NULL这个值的任何比较都会生产一个NULL值。您不能把任何值与一个 UNKNOWN值进行比较，并在逻辑上希望获得一个答案。您必须使用IS NULL操作符。 什么是索引?SQL Server 2000里有什么类型的索引? 任何有经验的数据库开发人员都应该能够很轻易地回答这个问题。一些经验不太多的开发人员能够回答这个问题，但是有些地方会说不清楚。 简单地说，索引是一个数据结构，用来快速访问数据库表格或者视图里的数据。在SQL Server里，它们有两种形式:聚集索引和非聚集索引。聚集索引在索引的叶级保存数据。这意味着不论聚集索引里有表格的哪个(或哪些)字段，这些字段都会按顺序被保存在表格。由于存在这种排序，所以每个表格只会有一个聚集索引。非聚集索引在索引的叶级有一个行标识符。这个行标识符是一个指向磁盘上数据的指针。它允许每个表格有多个非聚集索引。 什么是主键?什么是外键? 主键是表格里的(一个或多个)字段，只用来定义表格里的行;主键里的值总是唯一的。外键是一个用来建立两个表格之间关系的约束。这种关系一般都涉及一个表格里的主键字段与另外一个表格(尽管可能是同一个表格)里的一系列相连的字段。那么这些相连的字段就是外键。 什么是触发器?SQL Server 2000有什么不同类型的触发器? 让未来的数据库开发人员知道可用的触发器类型以及如何实现它们是非常有益的。 触发器是一种专用类型的存储过程，它被捆绑到SQL Server 2000的表格或者视图上。在SQL Server 2000里，有INSTEAD-OF和AFTER两种触发器。INSTEAD-OF触发器是替代数据操控语言(Data Manipulation Language，DML)语句对表格执行语句的存储过程。例如，如果我有一个用于TableA的INSTEAD-OF-UPDATE触发器，同时对这个表格执行一个更新语句，那么INSTEAD-OF-UPDATE触发器里的代码会执行，而不是我执行的更新语句则不会执行操作。 AFTER触发器要在DML语句在数据库里使用之后才执行。这些类型的触发器对于监视发生在数据库表格里的数据变化十分好用。 您如何确一个带有名为Fld1字段的TableB表格里只具有Fld1字段里的那些值，而这些值同时在名为TableA的表格的Fld1字段里? 这个与关系相关的问题有两个可能的答案。第一个答案(而且是您希望听到的答案)是使用外键限制。外键限制用来维护引用的完整性。它被用来确保表格里的字段只保存有已经在不同的(或者相同的)表格里的另一个字段里定义了的值。这个字段就是候选键(通常是另外一个表格的主键)。 另外一种答案是触发器。触发器可以被用来保证以另外一种方式实现与限制相同的作用，但是它非常难设置与维护，而且性能一般都很糟糕。由于这个原因，微软建议开发人员使用外键限制而不是触发器来维护引用的完整性。 对一个投入使用的在线事务处理表格有过多索引需要有什么样的性能考虑? 你正在寻找进行与数据操控有关的应聘人员。对一个表格的索引越多，数据库引擎用来更新、插入或者删除数据所需要的时间就越多，因为在数据操控发生的时候索引也必须要维护。 你可以用什么来确保表格里的字段只接受特定范围里的值? 这个问题可以用多种方式来回答，但是只有一个答案是“好”答案。您希望听到的回答是Check限制，它在数据库表格里被定义，用来限制输入该列的值。 触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求触发器在表格里被定义，这可能会在某些情况下影响到性能。因此，微软建议使用Check限制而不是其他的方式来限制域的完整性。 如果应聘者能够正确地回答这个问题，那么他的机会就非常大了，因为这表明他们具有使用存储过程的经验。 返回参数总是由存储过程返回，它用来表示存储过程是成功还是失败。返回参数总是INT数据类型。 OUTPUT参数明确要求由开发人员来指定，它可以返回其他类型的数据，例如字符型和数值型的值。(可以用作输出参数的数据类型是有一些限制的。)您可以在一个存储过程里使用多个OUTPUT参数，而您只能够使用一个返回参数。 什么是相关子查询?如何使用这些查询? 经验更加丰富的开发人员将能够准确地描述这种类型的查询。 相关子查询是一种包含子查询的特殊类型的查询。查询里包含的子查询会真正请求外部查询的值，从而形成一个类似于循环的状况。 SQL面试题（6） 原表: courseid coursename score 1 java 702 oracle 903 xml 404 jsp 30 5 servlet 80 为了便于阅读,查询此表后的结果显式如下(及格分数为60): courseid coursename score mark 1 java 70 pass2 oracle 90 pass3 xml 40 fail4 jsp 30 fail 5 servlet 80 pass 写出此查询语句 ORACLE : select courseid, coursename ,score ,decode（sign(score-60),-1,’fail’,’pass’) as mark from course (DECODE函数是ORACLE PL/SQL是功能强大的函数之一，目前还只有ORACLE公司的SQL提供了此函数) (SQL: select courseid, coursename ,score ,（case when score&lt;60 then ‘fail’ else ‘pass’ end) as mark from course )","path":"2019/06/30/sql面试题目-转/","date":"06-30","excerpt":"SQL常见面试题 转自: Different桐","tags":[{"name":"note","slug":"note","permalink":"https://starsuomali.github.io/tags/note/"},{"name":"sql","slug":"sql","permalink":"https://starsuomali.github.io/tags/sql/"}]},{"title":"线程锁synchronized锁定的细节","text":"线程锁synchronied的锁定小细节 线程锁synchronized的几种锁定方式|细节123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Created by suomali on 2019/6/18. * * syn的锁定 方法锁 和块锁this差不多 * syn锁定范围 太大容易拖慢效率 小了容易锁定失败 */public class TrainBF2 &#123; public static void main(String[] args) &#123; SynTrain12306 synTrain = new SynTrain12306(); new Thread(synTrain,&quot;小胡&quot;).start(); new Thread(synTrain,&quot;小高&quot;).start(); &#125;&#125;class SynTrain12306 implements Runnable&#123; private Integer Tickets = 4; private boolean flag = true; @Override public void run() &#123; while(flag)&#123; test3(); &#125; &#125; public void test3()&#123; //双重check if (Tickets &lt;= 0) &#123; //处理没票时的情况 如果没票了就都不用等了 flag = false; return; &#125; synchronized (this) &#123; if (Tickets &lt;= 0) &#123; //处理只剩下一张票的情况 都等在外边 但是当最后一张票被购买时就都不等了 flag = false; return; &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;买到了票,还有&quot; + --Tickets + &quot;张票&quot;); &#125; &#125; public void test2()&#123; synchronized (this) &#123; //锁定面积大的块 if (Tickets &lt;= 0) &#123; flag = false; return; &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;买到了票,还有&quot;+ --Tickets +&quot;张票&quot;); &#125; &#125; //直接锁定方法 使用这个方法的线程都需要等待 public synchronized void test()&#123; if(Tickets == 0)&#123; flag = false; return; &#125; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;买到了票,还有&quot;+ --Tickets +&quot;张票&quot;); &#125;&#125;","path":"2019/06/18/线程锁synchronied锁定的细节/","date":"06-18","excerpt":"线程锁synchronied的锁定小细节","tags":[{"name":"note","slug":"note","permalink":"https://starsuomali.github.io/tags/note/"},{"name":"synchronized","slug":"synchronized","permalink":"https://starsuomali.github.io/tags/synchronized/"}]},{"title":"Git学习笔记","text":"Git学习笔记，超好用的版本管理控制工具，工作效率直线上升！ Git学习笔记前言Git是一种版本控制管理工具，它是开源的。另一个比较有名的工具是SVN。Git与它的区别是：即使在无网络状态下也可以工作。Git可以和github（大型的Git托管平台）配合使用，使得代码的重新利用和修改极其的方便。安装Git 初始化一个仓库安装号Git之后，打开Git Bash，在一个你想作为仓库的文件夹下（也可以理解为某个项目文件夹），执行git init命令，现在这个文件夹就是一个Git仓库了，它可以控制你项目的版本，像一个时间机器一样。使用ls -a可以看到隐藏的.git文件。 注：Git中分为工作区域 暂存区域 以及仓库 常用命令 添加文件到Git工作区中git add 将工作区中的内容同步到暂存区域git commit -m &quot;同步说明&quot; 查看当前git的同步状态git status 查看工作区代码与暂存区代码的区别git diff 比较工作去中某文件与已提交的文件区别git diff HEAD -- &lt;filename.ext&gt; 查看git版本、同步情况和历史版本git log 控制查看结果为一行git log --pretty=oneline 查看历史分支图git log --graph --pretty=onelne --abbrev-commit 查看版本变动后之前的版本号 方便在回退错误后找回git reflog 版本控制git中使用Hashcode来记录不同的版本，每个版本都会在.git文件中记录，当我们需要回退版本或者取消版本回退时，都可以利用下面的命令来进行版本跳跃~ 回退到上上一个版本git reset --hard HEAD^^git reset --hard 上上的版本号 版本号不用写全，可以只写前几位 撤销暂存区域对应文件的修改git reset HEAD -- &lt;filename.ext&gt; 取消工作区中的修改，回退到上一个add或commitgit checkout -- &lt;filename&gt; 远程仓库命令在执行远程仓库命令之前，需要确认你的github上的sshkey生成并且保存了 在仓库的终端输入 ssh-keygen -t -C &quot;username&quot; (注：username时你github上的用户名) 一路回车，根据提示在默认路径下找到ssh文档，复制里面的ssh-sra到github的setting下 在github上创建一个和本地仓库（文件夹）同名的仓库，使用命令：git remote add origin git@github.com:用户名/仓库命.git(origin为远程仓库名，可以修改，一般默认) 通过命令git push -u origin master即可推送本地仓库中的文件到远程仓库中了。首次推送需要加-u，将远程仓库和本地仓库关联起来，之后的所有推送只需要输入git push origin master即可 在github上新建仓库后，可以直接从远程仓库克隆到本地 git clone git@github.com:username/respository_name.git git clone https://github.com/username/respository_name.git branch（分支）本地分支分支的创建有助于项目安全方便的推进，通过分支开发后合并到主分支当中去 创建分支：git branch branch_name 切换分支：git checkout branch_name 上边俩行命可以合到一起：git checkout -b branch_name 合并某分支到当前分支：git merge branch_name 合并分支采用fast-merge方式合并时不会留下历史记录，可强制停用fast模式：git merger --no-ff -m &quot;合并分支并留下记录&quot; branch_name 当合并有分歧的时候，在分歧的文件中Git会用 123451文件&lt;&lt;&lt;&lt;&lt;&lt; 分歧内容 =======分歧内容 &gt;&gt;&gt;&gt;&gt;&gt;文件2 的形式标注出来，到对应的文件中修改后，add、commit，再进行merge即可。 合并分支后可以使用命令删除被合并的分支：git branch -d branch_name需要删除未同步分支时可将-d 改为-D 远程分支 添加远程分支 通过github直接创建branch 通过本地创建branch后推送到远端git push origin remote_branch_name 注：在提交分支时，有可能你的搭档已经提交了内容，而与你所提交的内容产生了分歧，此时会报错。首先要通过git pull命令将内容拉取到本地，拉取时可能会拉取失败，因为没有同步分支连接，需要通过命令：git branch --set-upsteam-to=origin/branch_name branch_name可以完成链接。 删除远程分支git push origin :branch_name 删除远程仓库git push origin :username/branch_name 将远程分支同步到本地分支git checkout -b branch_name orgin/branch_name","path":"2019/06/01/Git学习笔记/","date":"06-01","excerpt":"Git学习笔记，超好用的版本管理控制工具，工作效率直线上升！","tags":[{"name":"note","slug":"note","permalink":"https://starsuomali.github.io/tags/note/"},{"name":"Git","slug":"Git","permalink":"https://starsuomali.github.io/tags/Git/"}]},{"title":"关于Markdown语法笔记","text":"第一次用Markdown写笔记,看看学习的成果！ markdown语法小计 有点简洁 有点方便 学会语法不需要太长时间(5分钟?) 一、标题一个#代表一级标题俩个#则代表二级标题例如： 123# 一级标题## 二级标题### 三级标题 效果： 一级标题二级标题三级标题注：标准语法末尾的#需要与文字相隔1个空格 二、字体 加粗：文字的左右分别用俩个*号包起来 效果：内容 斜体：文字的左右分别用一个*号包起来 效果：内容 斜体加粗:文字的左右分别用三个*包起来 效果：内容 删除体：要加删除线的文字左右分别用俩个~号包起来 效果：内容三、引用在引用的文字前加&gt;即可。引用可以嵌套： 123&gt;1&gt;&gt;2&gt;&gt;&gt;&gt;&gt;3 效果： 1 2 3 四、分割线三个或者三个以上的-或者*都可以分割 12---**** 效果： 五、图片 语法：[图片alt](图片地址 ‘’图片title’’)图片alt 是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移动到图片上面的时候就会看到。可以直接通过工具上传本地图片 六、超链接 语法：[超链接名](超链地址 ‘’超链接title’’)title可加可不加 注：Markdown本身语法不支持链接在新的页面中打开，如果想要在新的页面中打开可以使用html语法中的&lt;a&gt;来代替 七、列表 无序列表用-+*任何一种都可以 有序列表 数字加点 如：1.列表内容 列表镶嵌 上下一级之间相隔三个空格即可 八、表格 语法： 1234表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容 效果： 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行作用是分割表头和内容 有一个就行，多加几个是为了对齐文字默认居左 在-的俩边加:代表居中 注：原生的语法表的俩边都需要用|包起来，此处省略。 九、代码单行代码：代码之间分别用一个反引号包起来 ‘我是代码’ 代码块：代码之间分别用三个反引号包起来，且均独占一行 (```) 代码... 代码... 代码... (```)注：防止转译加了小括号，实际没有 十、流程图暂时用不到，就先不记了~（￣へ￣）","path":"2019/06/01/关于Markdown语法笔笔记/","date":"06-01","excerpt":"第一次用Markdown写笔记,看看学习的成果！","tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://starsuomali.github.io/tags/Markdown/"},{"name":"EditTools","slug":"EditTools","permalink":"https://starsuomali.github.io/tags/EditTools/"}]},{"title":"Hello World","text":"最初的”hello world”！ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/05/30/hello-world/","date":"05-30","excerpt":"最初的”hello world”！","tags":[{"name":"helloworld","slug":"helloworld","permalink":"https://starsuomali.github.io/tags/helloworld/"}]}]}